/* automatically generated by rust-bindgen */

pub const VRAPI_PRODUCT_VERSION: ::std::os::raw::c_uint = 1;
pub const VRAPI_MAJOR_VERSION: ::std::os::raw::c_uint = 1;
pub const VRAPI_MINOR_VERSION: ::std::os::raw::c_uint = 5;
pub const VRAPI_PATCH_VERSION: ::std::os::raw::c_uint = 0;
pub const VRAPI_BUILD_VERSION: ::std::os::raw::c_uint = 358458;
pub const VRAPI_BUILD_DESCRIPTION: &'static [u8; 12usize] =
    b"Development\x00";
pub const VRAPI_DRIVER_VERSION: ::std::os::raw::c_uint = 52620531;
pub const VRAPI_PI: f64 = 3.141592653589793;
pub const VRAPI_ZNEAR: f64 = 0.1;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct JNINativeInterface {
    _unused: [u8; 0],
}
pub type JNIEnv = *const JNINativeInterface;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct JNIInvokeInterface {
    _unused: [u8; 0],
}
pub type JavaVM = *const JNIInvokeInterface;
pub type jobject = *mut ::std::os::raw::c_void;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct ovrJava {
    pub Vm: *mut JavaVM,
    pub Env: *mut JNIEnv,
    pub ActivityObject: jobject,
}
#[test]
fn bindgen_test_layout_ovrJava() {
    assert_eq!(::std::mem::size_of::<ovrJava>() , 24usize , concat ! (
               "Size of: " , stringify ! ( ovrJava ) ));
    assert_eq! (::std::mem::align_of::<ovrJava>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( ovrJava ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ovrJava ) ) . Vm as * const _ as usize }
                , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( ovrJava ) , "::" ,
                stringify ! ( Vm ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ovrJava ) ) . Env as * const _ as usize }
                , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( ovrJava ) , "::" ,
                stringify ! ( Env ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ovrJava ) ) . ActivityObject as * const _
                as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( ovrJava ) , "::" ,
                stringify ! ( ActivityObject ) ));
}
impl Clone for ovrJava {
    fn clone(&self) -> Self { *self }
}
pub type ovrResult = ::std::os::raw::c_int;
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum ovrSuccessResult_ { ovrSuccess = 0, }
pub use self::ovrSuccessResult_ as ovrSuccessResult;
#[repr(i32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum ovrErrorResult_ {
    ovrError_MemoryAllocationFailure = -1000,
    ovrError_NotInitialized = -1004,
    ovrError_InvalidParameter = -1005,
    ovrError_DeviceUnavailable = -1010,
    ovrError_InvalidOperation = -1015,
    ovrError_UnsupportedDeviceType = -1050,
    ovrError_NoDevice = -1051,
    ovrError_NotImplemented = -1052,
    ovrResult_EnumSize = 2147483647,
}
pub use self::ovrErrorResult_ as ovrErrorResult;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct ovrVector2f_ {
    pub x: f32,
    pub y: f32,
}
#[test]
fn bindgen_test_layout_ovrVector2f_() {
    assert_eq!(::std::mem::size_of::<ovrVector2f_>() , 8usize , concat ! (
               "Size of: " , stringify ! ( ovrVector2f_ ) ));
    assert_eq! (::std::mem::align_of::<ovrVector2f_>() , 4usize , concat ! (
                "Alignment of " , stringify ! ( ovrVector2f_ ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ovrVector2f_ ) ) . x as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( ovrVector2f_ ) , "::" ,
                stringify ! ( x ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ovrVector2f_ ) ) . y as * const _ as
                usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( ovrVector2f_ ) , "::" ,
                stringify ! ( y ) ));
}
impl Clone for ovrVector2f_ {
    fn clone(&self) -> Self { *self }
}
pub type ovrVector2f = ovrVector2f_;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct ovrVector3f_ {
    pub x: f32,
    pub y: f32,
    pub z: f32,
}
#[test]
fn bindgen_test_layout_ovrVector3f_() {
    assert_eq!(::std::mem::size_of::<ovrVector3f_>() , 12usize , concat ! (
               "Size of: " , stringify ! ( ovrVector3f_ ) ));
    assert_eq! (::std::mem::align_of::<ovrVector3f_>() , 4usize , concat ! (
                "Alignment of " , stringify ! ( ovrVector3f_ ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ovrVector3f_ ) ) . x as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( ovrVector3f_ ) , "::" ,
                stringify ! ( x ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ovrVector3f_ ) ) . y as * const _ as
                usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( ovrVector3f_ ) , "::" ,
                stringify ! ( y ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ovrVector3f_ ) ) . z as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( ovrVector3f_ ) , "::" ,
                stringify ! ( z ) ));
}
impl Clone for ovrVector3f_ {
    fn clone(&self) -> Self { *self }
}
pub type ovrVector3f = ovrVector3f_;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct ovrVector4f_ {
    pub x: f32,
    pub y: f32,
    pub z: f32,
    pub w: f32,
}
#[test]
fn bindgen_test_layout_ovrVector4f_() {
    assert_eq!(::std::mem::size_of::<ovrVector4f_>() , 16usize , concat ! (
               "Size of: " , stringify ! ( ovrVector4f_ ) ));
    assert_eq! (::std::mem::align_of::<ovrVector4f_>() , 4usize , concat ! (
                "Alignment of " , stringify ! ( ovrVector4f_ ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ovrVector4f_ ) ) . x as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( ovrVector4f_ ) , "::" ,
                stringify ! ( x ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ovrVector4f_ ) ) . y as * const _ as
                usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( ovrVector4f_ ) , "::" ,
                stringify ! ( y ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ovrVector4f_ ) ) . z as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( ovrVector4f_ ) , "::" ,
                stringify ! ( z ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ovrVector4f_ ) ) . w as * const _ as
                usize } , 12usize , concat ! (
                "Alignment of field: " , stringify ! ( ovrVector4f_ ) , "::" ,
                stringify ! ( w ) ));
}
impl Clone for ovrVector4f_ {
    fn clone(&self) -> Self { *self }
}
pub type ovrVector4f = ovrVector4f_;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct ovrQuatf_ {
    pub x: f32,
    pub y: f32,
    pub z: f32,
    pub w: f32,
}
#[test]
fn bindgen_test_layout_ovrQuatf_() {
    assert_eq!(::std::mem::size_of::<ovrQuatf_>() , 16usize , concat ! (
               "Size of: " , stringify ! ( ovrQuatf_ ) ));
    assert_eq! (::std::mem::align_of::<ovrQuatf_>() , 4usize , concat ! (
                "Alignment of " , stringify ! ( ovrQuatf_ ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ovrQuatf_ ) ) . x as * const _ as usize }
                , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( ovrQuatf_ ) , "::" ,
                stringify ! ( x ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ovrQuatf_ ) ) . y as * const _ as usize }
                , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( ovrQuatf_ ) , "::" ,
                stringify ! ( y ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ovrQuatf_ ) ) . z as * const _ as usize }
                , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( ovrQuatf_ ) , "::" ,
                stringify ! ( z ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ovrQuatf_ ) ) . w as * const _ as usize }
                , 12usize , concat ! (
                "Alignment of field: " , stringify ! ( ovrQuatf_ ) , "::" ,
                stringify ! ( w ) ));
}
impl Clone for ovrQuatf_ {
    fn clone(&self) -> Self { *self }
}
pub type ovrQuatf = ovrQuatf_;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct ovrMatrix4f_ {
    pub M: [[f32; 4usize]; 4usize],
}
#[test]
fn bindgen_test_layout_ovrMatrix4f_() {
    assert_eq!(::std::mem::size_of::<ovrMatrix4f_>() , 64usize , concat ! (
               "Size of: " , stringify ! ( ovrMatrix4f_ ) ));
    assert_eq! (::std::mem::align_of::<ovrMatrix4f_>() , 4usize , concat ! (
                "Alignment of " , stringify ! ( ovrMatrix4f_ ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ovrMatrix4f_ ) ) . M as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( ovrMatrix4f_ ) , "::" ,
                stringify ! ( M ) ));
}
impl Clone for ovrMatrix4f_ {
    fn clone(&self) -> Self { *self }
}
pub type ovrMatrix4f = ovrMatrix4f_;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct ovrPosef_ {
    pub Orientation: ovrQuatf,
    pub Position: ovrVector3f,
}
#[test]
fn bindgen_test_layout_ovrPosef_() {
    assert_eq!(::std::mem::size_of::<ovrPosef_>() , 28usize , concat ! (
               "Size of: " , stringify ! ( ovrPosef_ ) ));
    assert_eq! (::std::mem::align_of::<ovrPosef_>() , 4usize , concat ! (
                "Alignment of " , stringify ! ( ovrPosef_ ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ovrPosef_ ) ) . Orientation as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( ovrPosef_ ) , "::" ,
                stringify ! ( Orientation ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ovrPosef_ ) ) . Position as * const _ as
                usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( ovrPosef_ ) , "::" ,
                stringify ! ( Position ) ));
}
impl Clone for ovrPosef_ {
    fn clone(&self) -> Self { *self }
}
pub type ovrPosef = ovrPosef_;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct ovrRectf_ {
    pub x: f32,
    pub y: f32,
    pub width: f32,
    pub height: f32,
}
#[test]
fn bindgen_test_layout_ovrRectf_() {
    assert_eq!(::std::mem::size_of::<ovrRectf_>() , 16usize , concat ! (
               "Size of: " , stringify ! ( ovrRectf_ ) ));
    assert_eq! (::std::mem::align_of::<ovrRectf_>() , 4usize , concat ! (
                "Alignment of " , stringify ! ( ovrRectf_ ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ovrRectf_ ) ) . x as * const _ as usize }
                , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( ovrRectf_ ) , "::" ,
                stringify ! ( x ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ovrRectf_ ) ) . y as * const _ as usize }
                , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( ovrRectf_ ) , "::" ,
                stringify ! ( y ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ovrRectf_ ) ) . width as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( ovrRectf_ ) , "::" ,
                stringify ! ( width ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ovrRectf_ ) ) . height as * const _ as
                usize } , 12usize , concat ! (
                "Alignment of field: " , stringify ! ( ovrRectf_ ) , "::" ,
                stringify ! ( height ) ));
}
impl Clone for ovrRectf_ {
    fn clone(&self) -> Self { *self }
}
pub type ovrRectf = ovrRectf_;
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum ovrBooleanResult { VRAPI_FALSE = 0, VRAPI_TRUE = 1, }
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum ovrStructureType {
    VRAPI_STRUCTURE_TYPE_INIT_PARMS = 1,
    VRAPI_STRUCTURE_TYPE_MODE_PARMS = 2,
    VRAPI_STRUCTURE_TYPE_FRAME_PARMS = 3,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum ovrDeviceType {
    VRAPI_DEVICE_TYPE_NOTE4 = 0,
    VRAPI_DEVICE_TYPE_NOTE5 = 1,
    VRAPI_DEVICE_TYPE_S6 = 2,
    VRAPI_DEVICE_TYPE_S7 = 3,
    VRAPI_DEVICE_TYPE_NOTE7 = 4,
    VRAPI_DEVICE_TYPE_RESERVED = 5,
    VRAPI_MAX_DEVICE_TYPES = 6,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum ovrHeadsetType {
    VRAPI_HEADSET_TYPE_R320 = 0,
    VRAPI_HEADSET_TYPE_R321 = 1,
    VRAPI_HEADSET_TYPE_R322 = 2,
    VRAPI_HEADSET_TYPE_R323 = 3,
    VRAPI_MAX_HEADSET_TYPES = 4,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum ovrDeviceRegion {
    VRAPI_DEVICE_REGION_UNSPECIFIED = 0,
    VRAPI_DEVICE_REGION_JAPAN = 1,
    VRAPI_DEVICE_REGION_CHINA = 2,
    VRAPI_MAX_DEVICE_REGIONS = 3,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum ovrVideoDecoderLimit {
    VRAPI_VIDEO_DECODER_LIMIT_4K_30FPS = 0,
    VRAPI_VIDEO_DECODER_LIMIT_4K_60FPS = 1,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum ovrSystemProperty {
    VRAPI_SYS_PROP_DEVICE_TYPE = 0,
    VRAPI_SYS_PROP_MAX_FULLSPEED_FRAMEBUFFER_SAMPLES = 1,
    VRAPI_SYS_PROP_DISPLAY_PIXELS_WIDE = 2,
    VRAPI_SYS_PROP_DISPLAY_PIXELS_HIGH = 3,
    VRAPI_SYS_PROP_DISPLAY_REFRESH_RATE = 4,
    VRAPI_SYS_PROP_SUGGESTED_EYE_TEXTURE_WIDTH = 5,
    VRAPI_SYS_PROP_SUGGESTED_EYE_TEXTURE_HEIGHT = 6,
    VRAPI_SYS_PROP_SUGGESTED_EYE_FOV_DEGREES_X = 7,
    VRAPI_SYS_PROP_SUGGESTED_EYE_FOV_DEGREES_Y = 8,
    VRAPI_SYS_PROP_EXT_SDCARD_PATH = 9,
    VRAPI_SYS_PROP_DEVICE_REGION = 10,
    VRAPI_SYS_PROP_VIDEO_DECODER_LIMIT = 11,
    VRAPI_SYS_PROP_HEADSET_TYPE = 12,
    VRAPI_SYS_PROP_BACK_BUTTON_SHORTPRESS_TIME = 13,
    VRAPI_SYS_PROP_BACK_BUTTON_DOUBLETAP_TIME = 14,
    VRAPI_SYS_PROP_MULTIVIEW_AVAILABLE = 128,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum ovrSystemStatus {
    VRAPI_SYS_STATUS_DOCKED = 0,
    VRAPI_SYS_STATUS_MOUNTED = 1,
    VRAPI_SYS_STATUS_THROTTLED = 2,
    VRAPI_SYS_STATUS_THROTTLED2 = 3,
    VRAPI_SYS_STATUS_THROTTLED_WARNING_LEVEL = 4,
    VRAPI_SYS_STATUS_RENDER_LATENCY_MILLISECONDS = 5,
    VRAPI_SYS_STATUS_TIMEWARP_LATENCY_MILLISECONDS = 6,
    VRAPI_SYS_STATUS_SCANOUT_LATENCY_MILLISECONDS = 7,
    VRAPI_SYS_STATUS_APP_FRAMES_PER_SECOND = 8,
    VRAPI_SYS_STATUS_SCREEN_TEARS_PER_SECOND = 9,
    VRAPI_SYS_STATUS_EARLY_FRAMES_PER_SECOND = 10,
    VRAPI_SYS_STATUS_STALE_FRAMES_PER_SECOND = 11,
    VRAPI_SYS_STATUS_HEADPHONES_PLUGGED_IN = 12,
    VRAPI_SYS_STATUS_RECENTER_COUNT = 13,
    VRAPI_SYS_STATUS_FRONT_BUFFER_PROTECTED = 128,
    VRAPI_SYS_STATUS_FRONT_BUFFER_565 = 129,
    VRAPI_SYS_STATUS_FRONT_BUFFER_SRGB = 130,
}
#[repr(i32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum ovrInitializeStatus {
    VRAPI_INITIALIZE_SUCCESS = 0,
    VRAPI_INITIALIZE_UNKNOWN_ERROR = -1,
    VRAPI_INITIALIZE_PERMISSIONS_ERROR = -2,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum ovrGraphicsAPI {
    VRAPI_GRAPHICS_API_OPENGL_ES_2 = 66048,
    VRAPI_GRAPHICS_API_OPENGL_ES_3 = 66304,
    VRAPI_GRAPHICS_API_OPENGL_COMPAT = 131328,
    VRAPI_GRAPHICS_API_OPENGL_CORE_3 = 131840,
    VRAPI_GRAPHICS_API_OPENGL_CORE_4 = 132096,
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct ovrInitParms {
    pub Type: ovrStructureType,
    pub ProductVersion: ::std::os::raw::c_int,
    pub MajorVersion: ::std::os::raw::c_int,
    pub MinorVersion: ::std::os::raw::c_int,
    pub PatchVersion: ::std::os::raw::c_int,
    pub GraphicsAPI: ovrGraphicsAPI,
    pub Java: ovrJava,
}
#[test]
fn bindgen_test_layout_ovrInitParms() {
    assert_eq!(::std::mem::size_of::<ovrInitParms>() , 48usize , concat ! (
               "Size of: " , stringify ! ( ovrInitParms ) ));
    assert_eq! (::std::mem::align_of::<ovrInitParms>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( ovrInitParms ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ovrInitParms ) ) . Type as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( ovrInitParms ) , "::" ,
                stringify ! ( Type ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ovrInitParms ) ) . ProductVersion as *
                const _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( ovrInitParms ) , "::" ,
                stringify ! ( ProductVersion ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ovrInitParms ) ) . MajorVersion as *
                const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( ovrInitParms ) , "::" ,
                stringify ! ( MajorVersion ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ovrInitParms ) ) . MinorVersion as *
                const _ as usize } , 12usize , concat ! (
                "Alignment of field: " , stringify ! ( ovrInitParms ) , "::" ,
                stringify ! ( MinorVersion ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ovrInitParms ) ) . PatchVersion as *
                const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( ovrInitParms ) , "::" ,
                stringify ! ( PatchVersion ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ovrInitParms ) ) . GraphicsAPI as * const
                _ as usize } , 20usize , concat ! (
                "Alignment of field: " , stringify ! ( ovrInitParms ) , "::" ,
                stringify ! ( GraphicsAPI ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ovrInitParms ) ) . Java as * const _ as
                usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( ovrInitParms ) , "::" ,
                stringify ! ( Java ) ));
}
impl Clone for ovrInitParms {
    fn clone(&self) -> Self { *self }
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum ovrModeFlags {
    VRAPI_MODE_FLAG_ALLOW_POWER_SAVE = 255,
    VRAPI_MODE_FLAG_RESET_WINDOW_FULLSCREEN = 65280,
    VRAPI_MODE_FLAG_NATIVE_WINDOW = 65536,
    VRAPI_MODE_FLAG_FRONT_BUFFER_PROTECTED = 131072,
    VRAPI_MODE_FLAG_FRONT_BUFFER_565 = 262144,
    VRAPI_MODE_FLAG_FRONT_BUFFER_SRGB = 524288,
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct ovrModeParms {
    pub Type: ovrStructureType,
    pub Flags: ::std::os::raw::c_uint,
    pub Java: ovrJava,
    pub Display: ::std::os::raw::c_ulonglong,
    pub WindowSurface: ::std::os::raw::c_ulonglong,
    pub ShareContext: ::std::os::raw::c_ulonglong,
}
#[test]
fn bindgen_test_layout_ovrModeParms() {
    assert_eq!(::std::mem::size_of::<ovrModeParms>() , 56usize , concat ! (
               "Size of: " , stringify ! ( ovrModeParms ) ));
    assert_eq! (::std::mem::align_of::<ovrModeParms>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( ovrModeParms ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ovrModeParms ) ) . Type as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( ovrModeParms ) , "::" ,
                stringify ! ( Type ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ovrModeParms ) ) . Flags as * const _ as
                usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( ovrModeParms ) , "::" ,
                stringify ! ( Flags ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ovrModeParms ) ) . Java as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( ovrModeParms ) , "::" ,
                stringify ! ( Java ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ovrModeParms ) ) . Display as * const _
                as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( ovrModeParms ) , "::" ,
                stringify ! ( Display ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ovrModeParms ) ) . WindowSurface as *
                const _ as usize } , 40usize , concat ! (
                "Alignment of field: " , stringify ! ( ovrModeParms ) , "::" ,
                stringify ! ( WindowSurface ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ovrModeParms ) ) . ShareContext as *
                const _ as usize } , 48usize , concat ! (
                "Alignment of field: " , stringify ! ( ovrModeParms ) , "::" ,
                stringify ! ( ShareContext ) ));
}
impl Clone for ovrModeParms {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ovrMobile {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct ovrRigidBodyPosef_ {
    pub Pose: ovrPosef,
    pub AngularVelocity: ovrVector3f,
    pub LinearVelocity: ovrVector3f,
    pub AngularAcceleration: ovrVector3f,
    pub LinearAcceleration: ovrVector3f,
    pub dead10: [::std::os::raw::c_uchar; 4usize],
    pub TimeInSeconds: f64,
    pub PredictionInSeconds: f64,
}
#[test]
fn bindgen_test_layout_ovrRigidBodyPosef_() {
    assert_eq!(::std::mem::size_of::<ovrRigidBodyPosef_>() , 96usize , concat
               ! ( "Size of: " , stringify ! ( ovrRigidBodyPosef_ ) ));
    assert_eq! (::std::mem::align_of::<ovrRigidBodyPosef_>() , 8usize , concat
                ! ( "Alignment of " , stringify ! ( ovrRigidBodyPosef_ ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ovrRigidBodyPosef_ ) ) . Pose as * const
                _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( ovrRigidBodyPosef_ ) ,
                "::" , stringify ! ( Pose ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ovrRigidBodyPosef_ ) ) . AngularVelocity
                as * const _ as usize } , 28usize , concat ! (
                "Alignment of field: " , stringify ! ( ovrRigidBodyPosef_ ) ,
                "::" , stringify ! ( AngularVelocity ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ovrRigidBodyPosef_ ) ) . LinearVelocity
                as * const _ as usize } , 40usize , concat ! (
                "Alignment of field: " , stringify ! ( ovrRigidBodyPosef_ ) ,
                "::" , stringify ! ( LinearVelocity ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ovrRigidBodyPosef_ ) ) .
                AngularAcceleration as * const _ as usize } , 52usize , concat
                ! (
                "Alignment of field: " , stringify ! ( ovrRigidBodyPosef_ ) ,
                "::" , stringify ! ( AngularAcceleration ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ovrRigidBodyPosef_ ) ) .
                LinearAcceleration as * const _ as usize } , 64usize , concat
                ! (
                "Alignment of field: " , stringify ! ( ovrRigidBodyPosef_ ) ,
                "::" , stringify ! ( LinearAcceleration ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ovrRigidBodyPosef_ ) ) . dead10 as *
                const _ as usize } , 76usize , concat ! (
                "Alignment of field: " , stringify ! ( ovrRigidBodyPosef_ ) ,
                "::" , stringify ! ( dead10 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ovrRigidBodyPosef_ ) ) . TimeInSeconds as
                * const _ as usize } , 80usize , concat ! (
                "Alignment of field: " , stringify ! ( ovrRigidBodyPosef_ ) ,
                "::" , stringify ! ( TimeInSeconds ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ovrRigidBodyPosef_ ) ) .
                PredictionInSeconds as * const _ as usize } , 88usize , concat
                ! (
                "Alignment of field: " , stringify ! ( ovrRigidBodyPosef_ ) ,
                "::" , stringify ! ( PredictionInSeconds ) ));
}
impl Clone for ovrRigidBodyPosef_ {
    fn clone(&self) -> Self { *self }
}
pub type ovrRigidBodyPosef = ovrRigidBodyPosef_;
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum ovrTrackingStatus {
    VRAPI_TRACKING_STATUS_ORIENTATION_TRACKED = 1,
    VRAPI_TRACKING_STATUS_POSITION_TRACKED = 2,
    VRAPI_TRACKING_STATUS_HMD_CONNECTED = 128,
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct ovrTracking_ {
    pub Status: ::std::os::raw::c_uint,
    pub dead12: [::std::os::raw::c_uchar; 4usize],
    pub HeadPose: ovrRigidBodyPosef,
}
#[test]
fn bindgen_test_layout_ovrTracking_() {
    assert_eq!(::std::mem::size_of::<ovrTracking_>() , 104usize , concat ! (
               "Size of: " , stringify ! ( ovrTracking_ ) ));
    assert_eq! (::std::mem::align_of::<ovrTracking_>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( ovrTracking_ ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ovrTracking_ ) ) . Status as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( ovrTracking_ ) , "::" ,
                stringify ! ( Status ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ovrTracking_ ) ) . dead12 as * const _ as
                usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( ovrTracking_ ) , "::" ,
                stringify ! ( dead12 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ovrTracking_ ) ) . HeadPose as * const _
                as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( ovrTracking_ ) , "::" ,
                stringify ! ( HeadPose ) ));
}
impl Clone for ovrTracking_ {
    fn clone(&self) -> Self { *self }
}
pub type ovrTracking = ovrTracking_;
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum ovrTextureType {
    VRAPI_TEXTURE_TYPE_2D = 0,
    VRAPI_TEXTURE_TYPE_2D_EXTERNAL = 1,
    VRAPI_TEXTURE_TYPE_2D_ARRAY = 2,
    VRAPI_TEXTURE_TYPE_CUBE = 3,
    VRAPI_TEXTURE_TYPE_MAX = 4,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum ovrTextureFormat {
    VRAPI_TEXTURE_FORMAT_NONE = 0,
    VRAPI_TEXTURE_FORMAT_565 = 1,
    VRAPI_TEXTURE_FORMAT_5551 = 2,
    VRAPI_TEXTURE_FORMAT_4444 = 3,
    VRAPI_TEXTURE_FORMAT_8888 = 4,
    VRAPI_TEXTURE_FORMAT_8888_sRGB = 5,
    VRAPI_TEXTURE_FORMAT_RGBA16F = 6,
    VRAPI_TEXTURE_FORMAT_DEPTH_16 = 7,
    VRAPI_TEXTURE_FORMAT_DEPTH_24 = 8,
    VRAPI_TEXTURE_FORMAT_DEPTH_24_STENCIL_8 = 9,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum ovrDefaultTextureSwapChain {
    VRAPI_DEFAULT_TEXTURE_SWAPCHAIN_BLACK = 1,
    VRAPI_DEFAULT_TEXTURE_SWAPCHAIN_LOADING_ICON = 2,
}
#[repr(i32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum ovrTextureSwapChainSettings {
    VRAPI_TEXTURE_SWAPCHAIN_FULL_MIP_CHAIN = -1,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ovrTextureSwapChain {
    _unused: [u8; 0],
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum ovrFrameFlags {
    VRAPI_FRAME_FLAG_INHIBIT_SRGB_FRAMEBUFFER = 1,
    VRAPI_FRAME_FLAG_FLUSH = 2,
    VRAPI_FRAME_FLAG_FINAL = 4,
    VRAPI_FRAME_FLAG_INHIBIT_VOLUME_LAYER = 64,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum ovrFrameLayerFlags {
    VRAPI_FRAME_LAYER_FLAG_WRITE_ALPHA = 1,
    VRAPI_FRAME_LAYER_FLAG_CHROMATIC_ABERRATION_CORRECTION = 2,
    VRAPI_FRAME_LAYER_FLAG_FIXED_TO_VIEW = 4,
    VRAPI_FRAME_LAYER_FLAG_SPIN = 8,
    VRAPI_FRAME_LAYER_FLAG_CLIP_TO_TEXTURE_RECT = 16,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum ovrFrameLayerEye {
    VRAPI_FRAME_LAYER_EYE_LEFT = 0,
    VRAPI_FRAME_LAYER_EYE_RIGHT = 1,
    VRAPI_FRAME_LAYER_EYE_MAX = 2,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum ovrFrameLayerBlend {
    VRAPI_FRAME_LAYER_BLEND_ZERO = 0,
    VRAPI_FRAME_LAYER_BLEND_ONE = 1,
    VRAPI_FRAME_LAYER_BLEND_SRC_ALPHA = 2,
    VRAPI_FRAME_LAYER_BLEND_DST_ALPHA = 3,
    VRAPI_FRAME_LAYER_BLEND_ONE_MINUS_DST_ALPHA = 4,
    VRAPI_FRAME_LAYER_BLEND_ONE_MINUS_SRC_ALPHA = 5,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum ovrFrameLayerType { VRAPI_FRAME_LAYER_TYPE_MAX = 4, }
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum ovrExtraLatencyMode {
    VRAPI_EXTRA_LATENCY_MODE_OFF = 0,
    VRAPI_EXTRA_LATENCY_MODE_ON = 1,
    VRAPI_EXTRA_LATENCY_MODE_DYNAMIC = 2,
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct ovrFrameLayerTexture {
    pub ColorTextureSwapChain: *mut ovrTextureSwapChain,
    pub DepthTextureSwapChain: *mut ovrTextureSwapChain,
    pub TextureSwapChainIndex: ::std::os::raw::c_int,
    pub TexCoordsFromTanAngles: ovrMatrix4f,
    pub TextureRect: ovrRectf,
    pub dead14: [::std::os::raw::c_uchar; 4usize],
    pub HeadPose: ovrRigidBodyPosef,
    pub CompletionFence: ::std::os::raw::c_ulonglong,
}
#[test]
fn bindgen_test_layout_ovrFrameLayerTexture() {
    assert_eq!(::std::mem::size_of::<ovrFrameLayerTexture>() , 208usize ,
               concat ! ( "Size of: " , stringify ! ( ovrFrameLayerTexture )
               ));
    assert_eq! (::std::mem::align_of::<ovrFrameLayerTexture>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( ovrFrameLayerTexture ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ovrFrameLayerTexture ) ) .
                ColorTextureSwapChain as * const _ as usize } , 0usize ,
                concat ! (
                "Alignment of field: " , stringify ! ( ovrFrameLayerTexture )
                , "::" , stringify ! ( ColorTextureSwapChain ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ovrFrameLayerTexture ) ) .
                DepthTextureSwapChain as * const _ as usize } , 8usize ,
                concat ! (
                "Alignment of field: " , stringify ! ( ovrFrameLayerTexture )
                , "::" , stringify ! ( DepthTextureSwapChain ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ovrFrameLayerTexture ) ) .
                TextureSwapChainIndex as * const _ as usize } , 16usize ,
                concat ! (
                "Alignment of field: " , stringify ! ( ovrFrameLayerTexture )
                , "::" , stringify ! ( TextureSwapChainIndex ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ovrFrameLayerTexture ) ) .
                TexCoordsFromTanAngles as * const _ as usize } , 20usize ,
                concat ! (
                "Alignment of field: " , stringify ! ( ovrFrameLayerTexture )
                , "::" , stringify ! ( TexCoordsFromTanAngles ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ovrFrameLayerTexture ) ) . TextureRect as
                * const _ as usize } , 84usize , concat ! (
                "Alignment of field: " , stringify ! ( ovrFrameLayerTexture )
                , "::" , stringify ! ( TextureRect ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ovrFrameLayerTexture ) ) . dead14 as *
                const _ as usize } , 100usize , concat ! (
                "Alignment of field: " , stringify ! ( ovrFrameLayerTexture )
                , "::" , stringify ! ( dead14 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ovrFrameLayerTexture ) ) . HeadPose as *
                const _ as usize } , 104usize , concat ! (
                "Alignment of field: " , stringify ! ( ovrFrameLayerTexture )
                , "::" , stringify ! ( HeadPose ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ovrFrameLayerTexture ) ) .
                CompletionFence as * const _ as usize } , 200usize , concat !
                (
                "Alignment of field: " , stringify ! ( ovrFrameLayerTexture )
                , "::" , stringify ! ( CompletionFence ) ));
}
impl Clone for ovrFrameLayerTexture {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct ovrFrameLayer {
    pub Textures: [ovrFrameLayerTexture; 2usize],
    pub SpinSpeed: f32,
    pub SpinScale: f32,
    pub ColorScale: f32,
    pub dead16: [::std::os::raw::c_uchar; 4usize],
    pub SrcBlend: ovrFrameLayerBlend,
    pub DstBlend: ovrFrameLayerBlend,
    pub Flags: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_ovrFrameLayer() {
    assert_eq!(::std::mem::size_of::<ovrFrameLayer>() , 448usize , concat ! (
               "Size of: " , stringify ! ( ovrFrameLayer ) ));
    assert_eq! (::std::mem::align_of::<ovrFrameLayer>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( ovrFrameLayer ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ovrFrameLayer ) ) . Textures as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( ovrFrameLayer ) , "::"
                , stringify ! ( Textures ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ovrFrameLayer ) ) . SpinSpeed as * const
                _ as usize } , 416usize , concat ! (
                "Alignment of field: " , stringify ! ( ovrFrameLayer ) , "::"
                , stringify ! ( SpinSpeed ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ovrFrameLayer ) ) . SpinScale as * const
                _ as usize } , 420usize , concat ! (
                "Alignment of field: " , stringify ! ( ovrFrameLayer ) , "::"
                , stringify ! ( SpinScale ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ovrFrameLayer ) ) . ColorScale as * const
                _ as usize } , 424usize , concat ! (
                "Alignment of field: " , stringify ! ( ovrFrameLayer ) , "::"
                , stringify ! ( ColorScale ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ovrFrameLayer ) ) . dead16 as * const _
                as usize } , 428usize , concat ! (
                "Alignment of field: " , stringify ! ( ovrFrameLayer ) , "::"
                , stringify ! ( dead16 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ovrFrameLayer ) ) . SrcBlend as * const _
                as usize } , 432usize , concat ! (
                "Alignment of field: " , stringify ! ( ovrFrameLayer ) , "::"
                , stringify ! ( SrcBlend ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ovrFrameLayer ) ) . DstBlend as * const _
                as usize } , 436usize , concat ! (
                "Alignment of field: " , stringify ! ( ovrFrameLayer ) , "::"
                , stringify ! ( DstBlend ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ovrFrameLayer ) ) . Flags as * const _ as
                usize } , 440usize , concat ! (
                "Alignment of field: " , stringify ! ( ovrFrameLayer ) , "::"
                , stringify ! ( Flags ) ));
}
impl Clone for ovrFrameLayer {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct ovrPerformanceParms {
    pub CpuLevel: ::std::os::raw::c_int,
    pub GpuLevel: ::std::os::raw::c_int,
    pub MainThreadTid: ::std::os::raw::c_int,
    pub RenderThreadTid: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_ovrPerformanceParms() {
    assert_eq!(::std::mem::size_of::<ovrPerformanceParms>() , 16usize , concat
               ! ( "Size of: " , stringify ! ( ovrPerformanceParms ) ));
    assert_eq! (::std::mem::align_of::<ovrPerformanceParms>() , 4usize ,
                concat ! (
                "Alignment of " , stringify ! ( ovrPerformanceParms ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ovrPerformanceParms ) ) . CpuLevel as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( ovrPerformanceParms ) ,
                "::" , stringify ! ( CpuLevel ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ovrPerformanceParms ) ) . GpuLevel as *
                const _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( ovrPerformanceParms ) ,
                "::" , stringify ! ( GpuLevel ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ovrPerformanceParms ) ) . MainThreadTid
                as * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( ovrPerformanceParms ) ,
                "::" , stringify ! ( MainThreadTid ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ovrPerformanceParms ) ) . RenderThreadTid
                as * const _ as usize } , 12usize , concat ! (
                "Alignment of field: " , stringify ! ( ovrPerformanceParms ) ,
                "::" , stringify ! ( RenderThreadTid ) ));
}
impl Clone for ovrPerformanceParms {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct ovrFrameParms {
    pub Type: ovrStructureType,
    pub dead19: [::std::os::raw::c_uchar; 4usize],
    pub Layers: [ovrFrameLayer; 4usize],
    pub LayerCount: ::std::os::raw::c_int,
    pub Flags: ::std::os::raw::c_int,
    pub FrameIndex: ::std::os::raw::c_longlong,
    pub MinimumVsyncs: ::std::os::raw::c_int,
    pub ExtraLatencyMode: ovrExtraLatencyMode,
    pub ExternalVelocity: ovrMatrix4f,
    pub SurfaceTextureObject: jobject,
    pub PerformanceParms: ovrPerformanceParms,
    pub Java: ovrJava,
}
#[test]
fn bindgen_test_layout_ovrFrameParms() {
    assert_eq!(::std::mem::size_of::<ovrFrameParms>() , 1936usize , concat ! (
               "Size of: " , stringify ! ( ovrFrameParms ) ));
    assert_eq! (::std::mem::align_of::<ovrFrameParms>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( ovrFrameParms ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ovrFrameParms ) ) . Type as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( ovrFrameParms ) , "::"
                , stringify ! ( Type ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ovrFrameParms ) ) . dead19 as * const _
                as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( ovrFrameParms ) , "::"
                , stringify ! ( dead19 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ovrFrameParms ) ) . Layers as * const _
                as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( ovrFrameParms ) , "::"
                , stringify ! ( Layers ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ovrFrameParms ) ) . LayerCount as * const
                _ as usize } , 1800usize , concat ! (
                "Alignment of field: " , stringify ! ( ovrFrameParms ) , "::"
                , stringify ! ( LayerCount ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ovrFrameParms ) ) . Flags as * const _ as
                usize } , 1804usize , concat ! (
                "Alignment of field: " , stringify ! ( ovrFrameParms ) , "::"
                , stringify ! ( Flags ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ovrFrameParms ) ) . FrameIndex as * const
                _ as usize } , 1808usize , concat ! (
                "Alignment of field: " , stringify ! ( ovrFrameParms ) , "::"
                , stringify ! ( FrameIndex ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ovrFrameParms ) ) . MinimumVsyncs as *
                const _ as usize } , 1816usize , concat ! (
                "Alignment of field: " , stringify ! ( ovrFrameParms ) , "::"
                , stringify ! ( MinimumVsyncs ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ovrFrameParms ) ) . ExtraLatencyMode as *
                const _ as usize } , 1820usize , concat ! (
                "Alignment of field: " , stringify ! ( ovrFrameParms ) , "::"
                , stringify ! ( ExtraLatencyMode ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ovrFrameParms ) ) . ExternalVelocity as *
                const _ as usize } , 1824usize , concat ! (
                "Alignment of field: " , stringify ! ( ovrFrameParms ) , "::"
                , stringify ! ( ExternalVelocity ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ovrFrameParms ) ) . SurfaceTextureObject
                as * const _ as usize } , 1888usize , concat ! (
                "Alignment of field: " , stringify ! ( ovrFrameParms ) , "::"
                , stringify ! ( SurfaceTextureObject ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ovrFrameParms ) ) . PerformanceParms as *
                const _ as usize } , 1896usize , concat ! (
                "Alignment of field: " , stringify ! ( ovrFrameParms ) , "::"
                , stringify ! ( PerformanceParms ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ovrFrameParms ) ) . Java as * const _ as
                usize } , 1912usize , concat ! (
                "Alignment of field: " , stringify ! ( ovrFrameParms ) , "::"
                , stringify ! ( Java ) ));
}
impl Clone for ovrFrameParms {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct ovrHeadModelParms {
    pub InterpupillaryDistance: f32,
    pub EyeHeight: f32,
    pub HeadModelDepth: f32,
    pub HeadModelHeight: f32,
}
#[test]
fn bindgen_test_layout_ovrHeadModelParms() {
    assert_eq!(::std::mem::size_of::<ovrHeadModelParms>() , 16usize , concat !
               ( "Size of: " , stringify ! ( ovrHeadModelParms ) ));
    assert_eq! (::std::mem::align_of::<ovrHeadModelParms>() , 4usize , concat
                ! ( "Alignment of " , stringify ! ( ovrHeadModelParms ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ovrHeadModelParms ) ) .
                InterpupillaryDistance as * const _ as usize } , 0usize ,
                concat ! (
                "Alignment of field: " , stringify ! ( ovrHeadModelParms ) ,
                "::" , stringify ! ( InterpupillaryDistance ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ovrHeadModelParms ) ) . EyeHeight as *
                const _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( ovrHeadModelParms ) ,
                "::" , stringify ! ( EyeHeight ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ovrHeadModelParms ) ) . HeadModelDepth as
                * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( ovrHeadModelParms ) ,
                "::" , stringify ! ( HeadModelDepth ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ovrHeadModelParms ) ) . HeadModelHeight
                as * const _ as usize } , 12usize , concat ! (
                "Alignment of field: " , stringify ! ( ovrHeadModelParms ) ,
                "::" , stringify ! ( HeadModelHeight ) ));
}
impl Clone for ovrHeadModelParms {
    fn clone(&self) -> Self { *self }
}
extern "C" {
    pub fn vrapi_GetTimeInSeconds() -> f64;
}
extern "C" {
    pub fn vrapi_GetVersionString() -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn vrapi_Initialize(initParms: *const ovrInitParms)
     -> ovrInitializeStatus;
}
extern "C" {
    pub fn vrapi_Shutdown();
}
extern "C" {
    pub fn vrapi_GetSystemPropertyInt(java: *const ovrJava,
                                      propType: ovrSystemProperty)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vrapi_GetSystemPropertyFloat(java: *const ovrJava,
                                        propType: ovrSystemProperty) -> f32;
}
extern "C" {
    pub fn vrapi_GetSystemPropertyString(java: *const ovrJava,
                                         propType: ovrSystemProperty)
     -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn vrapi_GetSystemStatusInt(java: *const ovrJava,
                                    statusType: ovrSystemStatus)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vrapi_GetSystemStatusFloat(java: *const ovrJava,
                                      statusType: ovrSystemStatus) -> f32;
}
extern "C" {
    pub fn vrapi_EnterVrMode(parms: *const ovrModeParms) -> *mut ovrMobile;
}
extern "C" {
    pub fn vrapi_LeaveVrMode(ovr: *mut ovrMobile);
}
extern "C" {
    pub fn vrapi_GetPredictedDisplayTime(ovr: *mut ovrMobile,
                                         frameIndex:
                                             ::std::os::raw::c_longlong)
     -> f64;
}
extern "C" {
    pub fn vrapi_GetPredictedTracking(ovr: *mut ovrMobile,
                                      absTimeInSeconds: f64) -> ovrTracking;
}
extern "C" {
    pub fn vrapi_RecenterPose(ovr: *mut ovrMobile);
}
extern "C" {
    pub fn vrapi_CreateTextureSwapChain2(type_: ovrTextureType,
                                         format: ovrTextureFormat,
                                         width: ::std::os::raw::c_int,
                                         height: ::std::os::raw::c_int,
                                         levels: ::std::os::raw::c_int,
                                         bufferCount: ::std::os::raw::c_int)
     -> *mut ovrTextureSwapChain;
}
extern "C" {
    pub fn vrapi_CreateTextureSwapChain(type_: ovrTextureType,
                                        format: ovrTextureFormat,
                                        width: ::std::os::raw::c_int,
                                        height: ::std::os::raw::c_int,
                                        levels: ::std::os::raw::c_int,
                                        buffered: bool)
     -> *mut ovrTextureSwapChain;
}
extern "C" {
    pub fn vrapi_DestroyTextureSwapChain(chain: *mut ovrTextureSwapChain);
}
extern "C" {
    pub fn vrapi_GetTextureSwapChainLength(chain: *mut ovrTextureSwapChain)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vrapi_GetTextureSwapChainHandle(chain: *mut ovrTextureSwapChain,
                                           index: ::std::os::raw::c_int)
     -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn vrapi_SetTextureSwapChainHandle(chain: *mut ovrTextureSwapChain,
                                           index: ::std::os::raw::c_int,
                                           handle: ::std::os::raw::c_uint);
}
extern "C" {
    pub fn vrapi_SubmitFrame(ovr: *mut ovrMobile,
                             parms: *const ovrFrameParms);
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum ovrButton_ {
    ovrButton_A = 1,
    ovrButton_B = 2,
    ovrButton_RThumb = 4,
    ovrButton_RShoulder = 8,
    ovrButton_X = 256,
    ovrButton_Y = 512,
    ovrButton_LThumb = 1024,
    ovrButton_LShoulder = 2048,
    ovrButton_Up = 65536,
    ovrButton_Down = 131072,
    ovrButton_Left = 262144,
    ovrButton_Right = 524288,
    ovrButton_Enter = 1048576,
    ovrButton_Back = 2097152,
    ovrButton_EnumSize = 2147483647,
}
pub use self::ovrButton_ as ovrButton;
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum ovrControllerType_ {
    ovrControllerType_None = 0,
    ovrControllerType_Reserved0 = 1,
    ovrControllerType_Reserved1 = 2,
    ovrControllerType_TrackedRemote = 4,
    ovrControllerType_Headset = 8,
    ovrControllerType_Reserved2 = 16,
    ovrControllerType_EnumSize = 2147483647,
}
pub use self::ovrControllerType_ as ovrControllerType;
pub type ovrDeviceID = u32;
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum ovrDeviceIdType_ { ovrDeviceIdType_Invalid = 2147483647, }
pub use self::ovrDeviceIdType_ as ovrDeviceIdType;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct ovrInputCapabilityHeader_ {
    pub Type: ovrControllerType,
    pub DeviceID: ovrDeviceID,
}
#[test]
fn bindgen_test_layout_ovrInputCapabilityHeader_() {
    assert_eq!(::std::mem::size_of::<ovrInputCapabilityHeader_>() , 8usize ,
               concat ! (
               "Size of: " , stringify ! ( ovrInputCapabilityHeader_ ) ));
    assert_eq! (::std::mem::align_of::<ovrInputCapabilityHeader_>() , 4usize ,
                concat ! (
                "Alignment of " , stringify ! ( ovrInputCapabilityHeader_ )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ovrInputCapabilityHeader_ ) ) . Type as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                ovrInputCapabilityHeader_ ) , "::" , stringify ! ( Type ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ovrInputCapabilityHeader_ ) ) . DeviceID
                as * const _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! (
                ovrInputCapabilityHeader_ ) , "::" , stringify ! ( DeviceID )
                ));
}
impl Clone for ovrInputCapabilityHeader_ {
    fn clone(&self) -> Self { *self }
}
pub type ovrInputCapabilityHeader = ovrInputCapabilityHeader_;
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum ovrControllerCapabilities_ {
    ovrControllerCaps_HasOrientationTracking = 1,
    ovrControllerCaps_HasPositionTracking = 2,
    ovrControllerCaps_LeftHand = 4,
    ovrControllerCaps_RightHand = 8,
    ovrControllerCaps_EnumSize = 2147483647,
}
pub use self::ovrControllerCapabilities_ as ovrControllerCapabilties;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct ovrInputTrackedRemoteCapabilities_ {
    pub Header: ovrInputCapabilityHeader,
    pub ControllerCapabilities: u32,
    pub ButtonCapabilities: u32,
    pub TrackpadMaxX: u16,
    pub TrackpadMaxY: u16,
    pub TrackpadSizeX: f32,
    pub TrackpadSizeY: f32,
}
#[test]
fn bindgen_test_layout_ovrInputTrackedRemoteCapabilities_() {
    assert_eq!(::std::mem::size_of::<ovrInputTrackedRemoteCapabilities_>() ,
               28usize , concat ! (
               "Size of: " , stringify ! ( ovrInputTrackedRemoteCapabilities_
               ) ));
    assert_eq! (::std::mem::align_of::<ovrInputTrackedRemoteCapabilities_>() ,
                4usize , concat ! (
                "Alignment of " , stringify ! (
                ovrInputTrackedRemoteCapabilities_ ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ovrInputTrackedRemoteCapabilities_ ) ) .
                Header as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                ovrInputTrackedRemoteCapabilities_ ) , "::" , stringify ! (
                Header ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ovrInputTrackedRemoteCapabilities_ ) ) .
                ControllerCapabilities as * const _ as usize } , 8usize ,
                concat ! (
                "Alignment of field: " , stringify ! (
                ovrInputTrackedRemoteCapabilities_ ) , "::" , stringify ! (
                ControllerCapabilities ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ovrInputTrackedRemoteCapabilities_ ) ) .
                ButtonCapabilities as * const _ as usize } , 12usize , concat
                ! (
                "Alignment of field: " , stringify ! (
                ovrInputTrackedRemoteCapabilities_ ) , "::" , stringify ! (
                ButtonCapabilities ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ovrInputTrackedRemoteCapabilities_ ) ) .
                TrackpadMaxX as * const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! (
                ovrInputTrackedRemoteCapabilities_ ) , "::" , stringify ! (
                TrackpadMaxX ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ovrInputTrackedRemoteCapabilities_ ) ) .
                TrackpadMaxY as * const _ as usize } , 18usize , concat ! (
                "Alignment of field: " , stringify ! (
                ovrInputTrackedRemoteCapabilities_ ) , "::" , stringify ! (
                TrackpadMaxY ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ovrInputTrackedRemoteCapabilities_ ) ) .
                TrackpadSizeX as * const _ as usize } , 20usize , concat ! (
                "Alignment of field: " , stringify ! (
                ovrInputTrackedRemoteCapabilities_ ) , "::" , stringify ! (
                TrackpadSizeX ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ovrInputTrackedRemoteCapabilities_ ) ) .
                TrackpadSizeY as * const _ as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! (
                ovrInputTrackedRemoteCapabilities_ ) , "::" , stringify ! (
                TrackpadSizeY ) ));
}
impl Clone for ovrInputTrackedRemoteCapabilities_ {
    fn clone(&self) -> Self { *self }
}
pub type ovrInputTrackedRemoteCapabilities =
    ovrInputTrackedRemoteCapabilities_;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct ovrInputHeadsetCapabilities_ {
    pub Header: ovrInputCapabilityHeader,
    pub ControllerCapabilities: u32,
    pub ButtonCapabilities: u32,
    pub TrackpadMaxX: u16,
    pub TrackpadMaxY: u16,
    pub TrackpadSizeX: f32,
    pub TrackpadSizeY: f32,
}
#[test]
fn bindgen_test_layout_ovrInputHeadsetCapabilities_() {
    assert_eq!(::std::mem::size_of::<ovrInputHeadsetCapabilities_>() , 28usize
               , concat ! (
               "Size of: " , stringify ! ( ovrInputHeadsetCapabilities_ ) ));
    assert_eq! (::std::mem::align_of::<ovrInputHeadsetCapabilities_>() ,
                4usize , concat ! (
                "Alignment of " , stringify ! ( ovrInputHeadsetCapabilities_ )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ovrInputHeadsetCapabilities_ ) ) . Header
                as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                ovrInputHeadsetCapabilities_ ) , "::" , stringify ! ( Header )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ovrInputHeadsetCapabilities_ ) ) .
                ControllerCapabilities as * const _ as usize } , 8usize ,
                concat ! (
                "Alignment of field: " , stringify ! (
                ovrInputHeadsetCapabilities_ ) , "::" , stringify ! (
                ControllerCapabilities ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ovrInputHeadsetCapabilities_ ) ) .
                ButtonCapabilities as * const _ as usize } , 12usize , concat
                ! (
                "Alignment of field: " , stringify ! (
                ovrInputHeadsetCapabilities_ ) , "::" , stringify ! (
                ButtonCapabilities ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ovrInputHeadsetCapabilities_ ) ) .
                TrackpadMaxX as * const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! (
                ovrInputHeadsetCapabilities_ ) , "::" , stringify ! (
                TrackpadMaxX ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ovrInputHeadsetCapabilities_ ) ) .
                TrackpadMaxY as * const _ as usize } , 18usize , concat ! (
                "Alignment of field: " , stringify ! (
                ovrInputHeadsetCapabilities_ ) , "::" , stringify ! (
                TrackpadMaxY ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ovrInputHeadsetCapabilities_ ) ) .
                TrackpadSizeX as * const _ as usize } , 20usize , concat ! (
                "Alignment of field: " , stringify ! (
                ovrInputHeadsetCapabilities_ ) , "::" , stringify ! (
                TrackpadSizeX ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ovrInputHeadsetCapabilities_ ) ) .
                TrackpadSizeY as * const _ as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! (
                ovrInputHeadsetCapabilities_ ) , "::" , stringify ! (
                TrackpadSizeY ) ));
}
impl Clone for ovrInputHeadsetCapabilities_ {
    fn clone(&self) -> Self { *self }
}
pub type ovrInputHeadsetCapabilities = ovrInputHeadsetCapabilities_;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct ovrInputStateHeader_ {
    pub ControllerType: ovrControllerType,
    pub TimeInSeconds: f64,
}
#[test]
fn bindgen_test_layout_ovrInputStateHeader_() {
    assert_eq!(::std::mem::size_of::<ovrInputStateHeader_>() , 16usize ,
               concat ! ( "Size of: " , stringify ! ( ovrInputStateHeader_ )
               ));
    assert_eq! (::std::mem::align_of::<ovrInputStateHeader_>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( ovrInputStateHeader_ ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ovrInputStateHeader_ ) ) . ControllerType
                as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( ovrInputStateHeader_ )
                , "::" , stringify ! ( ControllerType ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ovrInputStateHeader_ ) ) . TimeInSeconds
                as * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( ovrInputStateHeader_ )
                , "::" , stringify ! ( TimeInSeconds ) ));
}
impl Clone for ovrInputStateHeader_ {
    fn clone(&self) -> Self { *self }
}
pub type ovrInputStateHeader = ovrInputStateHeader_;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct ovrInputStateTrackedRemote_ {
    pub Header: ovrInputStateHeader,
    pub Buttons: u32,
    pub TrackpadStatus: u32,
    pub TrackpadPosition: ovrVector2f,
    pub BatteryPercentRemaining: u8,
    pub RecenterCount: u8,
    pub Reserved: u16,
}
#[test]
fn bindgen_test_layout_ovrInputStateTrackedRemote_() {
    assert_eq!(::std::mem::size_of::<ovrInputStateTrackedRemote_>() , 40usize
               , concat ! (
               "Size of: " , stringify ! ( ovrInputStateTrackedRemote_ ) ));
    assert_eq! (::std::mem::align_of::<ovrInputStateTrackedRemote_>() , 8usize
                , concat ! (
                "Alignment of " , stringify ! ( ovrInputStateTrackedRemote_ )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ovrInputStateTrackedRemote_ ) ) . Header
                as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                ovrInputStateTrackedRemote_ ) , "::" , stringify ! ( Header )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ovrInputStateTrackedRemote_ ) ) . Buttons
                as * const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! (
                ovrInputStateTrackedRemote_ ) , "::" , stringify ! ( Buttons )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ovrInputStateTrackedRemote_ ) ) .
                TrackpadStatus as * const _ as usize } , 20usize , concat ! (
                "Alignment of field: " , stringify ! (
                ovrInputStateTrackedRemote_ ) , "::" , stringify ! (
                TrackpadStatus ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ovrInputStateTrackedRemote_ ) ) .
                TrackpadPosition as * const _ as usize } , 24usize , concat !
                (
                "Alignment of field: " , stringify ! (
                ovrInputStateTrackedRemote_ ) , "::" , stringify ! (
                TrackpadPosition ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ovrInputStateTrackedRemote_ ) ) .
                BatteryPercentRemaining as * const _ as usize } , 32usize ,
                concat ! (
                "Alignment of field: " , stringify ! (
                ovrInputStateTrackedRemote_ ) , "::" , stringify ! (
                BatteryPercentRemaining ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ovrInputStateTrackedRemote_ ) ) .
                RecenterCount as * const _ as usize } , 33usize , concat ! (
                "Alignment of field: " , stringify ! (
                ovrInputStateTrackedRemote_ ) , "::" , stringify ! (
                RecenterCount ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ovrInputStateTrackedRemote_ ) ) .
                Reserved as * const _ as usize } , 34usize , concat ! (
                "Alignment of field: " , stringify ! (
                ovrInputStateTrackedRemote_ ) , "::" , stringify ! ( Reserved
                ) ));
}
impl Clone for ovrInputStateTrackedRemote_ {
    fn clone(&self) -> Self { *self }
}
pub type ovrInputStateTrackedRemote = ovrInputStateTrackedRemote_;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct ovrInputStateHeadset_ {
    pub Header: ovrInputStateHeader,
    pub Buttons: u32,
    pub TrackpadStatus: u32,
    pub TrackpadPosition: ovrVector2f,
}
#[test]
fn bindgen_test_layout_ovrInputStateHeadset_() {
    assert_eq!(::std::mem::size_of::<ovrInputStateHeadset_>() , 32usize ,
               concat ! ( "Size of: " , stringify ! ( ovrInputStateHeadset_ )
               ));
    assert_eq! (::std::mem::align_of::<ovrInputStateHeadset_>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( ovrInputStateHeadset_ ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ovrInputStateHeadset_ ) ) . Header as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( ovrInputStateHeadset_ )
                , "::" , stringify ! ( Header ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ovrInputStateHeadset_ ) ) . Buttons as *
                const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( ovrInputStateHeadset_ )
                , "::" , stringify ! ( Buttons ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ovrInputStateHeadset_ ) ) .
                TrackpadStatus as * const _ as usize } , 20usize , concat ! (
                "Alignment of field: " , stringify ! ( ovrInputStateHeadset_ )
                , "::" , stringify ! ( TrackpadStatus ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ovrInputStateHeadset_ ) ) .
                TrackpadPosition as * const _ as usize } , 24usize , concat !
                (
                "Alignment of field: " , stringify ! ( ovrInputStateHeadset_ )
                , "::" , stringify ! ( TrackpadPosition ) ));
}
impl Clone for ovrInputStateHeadset_ {
    fn clone(&self) -> Self { *self }
}
pub type ovrInputStateHeadset = ovrInputStateHeadset_;
extern "C" {
    pub fn vrapi_EnumerateInputDevices(ovr: *mut ovrMobile, index: u32,
                                       capsHeader:
                                           *mut ovrInputCapabilityHeader)
     -> ovrResult;
}
extern "C" {
    pub fn vrapi_GetInputDeviceCapabilities(ovr: *mut ovrMobile,
                                            capsHeader:
                                                *mut ovrInputCapabilityHeader)
     -> ovrResult;
}
extern "C" {
    pub fn vrapi_GetCurrentInputState(ovr: *mut ovrMobile,
                                      deviceID: ovrDeviceID,
                                      inputState: *mut ovrInputStateHeader)
     -> ovrResult;
}
extern "C" {
    pub fn vrapi_GetInputTrackingState(ovr: *mut ovrMobile,
                                       deviceID: ovrDeviceID,
                                       absTimeInSeconds: f64,
                                       tracking: *mut ovrTracking)
     -> ovrResult;
}
extern "C" {
    pub fn vrapi_RecenterInputPose(ovr: *mut ovrMobile,
                                   deviceID: ovrDeviceID);
}
extern "C" {
    pub fn vrapi_SetRemoteEmulation(ovr: *mut ovrMobile, emulationOn: bool)
     -> ovrResult;
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum ovrFrameInit {
    VRAPI_FRAME_INIT_DEFAULT = 0,
    VRAPI_FRAME_INIT_BLACK = 1,
    VRAPI_FRAME_INIT_BLACK_FLUSH = 2,
    VRAPI_FRAME_INIT_BLACK_FINAL = 3,
    VRAPI_FRAME_INIT_LOADING_ICON = 4,
    VRAPI_FRAME_INIT_LOADING_ICON_FLUSH = 5,
    VRAPI_FRAME_INIT_MESSAGE = 6,
    VRAPI_FRAME_INIT_MESSAGE_FLUSH = 7,
}
